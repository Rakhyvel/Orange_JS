Todo:
x indexing operator
x array literals
x else statements
x return statements
x array initialize
x character literal
x string literal
x real vs integer literal
x struct definitions
x struct extension
x global variable declarations/definitions
x static modifier for modules
x constants
x private modifier for higher levels
x module access ":"
x syntax validation

x type validation
x identifier validation
x access validation
x static module validation
x struct dot op. for extend structs
x constant modify validation
x constant define & no declare validation
x struct extension
x line numbers/file info for tokens/ast, line list for each module
x better error messages
x program has starting point called "int start(char array args)"?

x switch back to curly brace syntax to blocks
x add back semicolon syntax
x blocks scope variables, not functions
x assert ifs must have block, else must have if or block
x assert while must have block
x add brackets back to tmLang
x struct parameters
x structs cannot have any statements besides var defines, and no non-static access!
x super token for structs with parents (parents definition call)
x multiple char punctuation
x C like comment syntax
x array [] syntax
    x int[] a = new int[5];
    x int[] a = new int[](1, 2, 3, 4, 5);
x finish tmLang(null, text, struct name:parent, array, multi char punc, super, cast)
x remove struct inheritance
x remove struct initializer functions
x return struct function signature syntax
x length field for arrays
x validate parameter types exist for functions, structs
x casting
x the Any type
x null

x add file error messages
x zero arg struct init
x add output name flag
x add target flag
x add code generation
x add system module
x add canvas module
x width(), height()
x mouseX, mouseY
- items
- prerequisite: function references
    - keyboard input
    - requestAnimationFrame()
- add function pointer to blocks as well, replace (function, module) parameters in validator with blocks
- add image drawing
- enums
- throw/catch (which just sets errno, but predictably)


    // Each struct should be a class with only a constructor
    fprintf(out, "/*** BEGIN STRUCTS ****/\n");
    struct list* dataStructs = map_getKeyList(program->dataStructsMap);   
    struct listElem* dataStructElem;
    for(dataStructElem = list_begin(dataStructs); dataStructElem != list_end(dataStructs); dataStructElem = list_next(dataStructElem)) {
        struct dataStruct* dataStruct = map_get(program->dataStructsMap, (char*)dataStructElem->data);
        generateStruct(out, dataStruct);
    }
    fprintf(out, "\n/*** BEGIN SYSTEM/CANVAS ****/\n");
    fprintf(out, "%s", systemDef);
    fprintf(out, "%s", canvasDef);
    fprintf(out, "\n/*** BEGIN GLOBALS ****/\n");
    struct list* modules = map_getKeyList(program->modulesMap);   
    struct listElem* moduleElem;
    // Globals
    for(moduleElem = list_begin(modules); moduleElem != list_end(modules); moduleElem = list_next(moduleElem)) {
        struct module* module = map_get(program->modulesMap, (char*)moduleElem->data);
        if(!strcmp(module->name, "System") || !strcmp(module->name, "Canvas")) {
            continue;
        }
        struct list* globals = map_getKeyList(module->block->varMap);
        struct listElem* globalElem;
        for(globalElem = list_begin(globals); globalElem != list_end(globals); globalElem = list_next(globalElem)) {
            struct variable* global = map_get(module->block->varMap, (char*)globalElem->data);
            generateGlobal(out, module->name, global);
        }
    }
    fprintf(out, "\n/*** BEGIN FUNCTIONS ****/\n");
    // Functions
    for(moduleElem = list_begin(modules); moduleElem != list_end(modules); moduleElem = list_next(moduleElem)) {
        struct module* module = map_get(program->modulesMap, (char*)moduleElem->data);
        if(!strcmp(module->name, "System") || !strcmp(module->name, "Canvas")) {
            continue;
        }
        struct list* functions = map_getKeyList(module->functionsMap);
        struct listElem* functionElem;
        for(functionElem = list_begin(functions); functionElem != list_end(functions); functionElem = list_next(functionElem)) {
            struct function* function = map_get(module->functionsMap, (char*)functionElem->data);
            if(!strcmp(function->self.name, "start")) {
                startMod=module->name;
                startFunc=function->self.name;
            }
            generateFunction(out, module->name, function);
        }
    }
    fprintf(out, "%s_%s();", startMod, startFunc);